# frozen_string_literal: true

RSpec.describe Twirp::ProtocPlugin do
  describe "#process" do
    describe "parameter validation" do
      context "when passing an invalid parameter" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p unrecognized -f service_code_gen_request_unrecognized_param_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_unrecognized_param_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "Invalid option: unrecognized")
        end
      end

      context "when passing an invalid value for the skip-empty flag" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p skip-empty=true -f service_code_gen_request_invalid_skip_empty_value_param_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_invalid_skip_empty_value_param_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "Unexpected value passed to skip-empty flag: true")
        end
      end

      context "when passing an empty value for the generate flag" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p generate= -f service_code_gen_request_generate_param_missing_value_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_generate_param_missing_value_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "Unexpected missing value for generate option. Please supply one of: service, client, both.")
        end
      end

      context "when passing an invalid value for the generate flag" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p generate=bad -f service_code_gen_request_generate_param_invalid_value_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_generate_param_invalid_value_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "The generate value must be one of: service, client, both. Unexpectedly received: bad")
        end
      end
    end

    context "when using the example from the original go plugin" do
      # The `service.proto` fixture is from:
      #   https://github.com/arthurnn/twirp-ruby/blob/v1.11.0/example/hello_world/service.proto
      #
      # Generate code gen request fixture:
      #   `./spec/support/create_fixture -b -f service_code_gen_request_pb.bin ./spec/fixtures/service.proto`
      let(:service_code_gen_request_pb) { fixture("service_code_gen_request_pb.bin").read }

      it "generates expected output" do
        response_pb = Twirp::ProtocPlugin.process(service_code_gen_request_pb)
        response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

        expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
        expect(response.file.size).to eq(1)
        expect(response.file.first.name).to eq("spec/fixtures/service_twirp.rb")
        # Match the general output of the 1.11.0 go plugin when ran against the same service.proto.
        # See: https://github.com/arthurnn/twirp-ruby/blob/v1.11.0/example/hello_world/service_twirp.rb
        expect(response.file.first.content).to eq <<~EOF
          # frozen_string_literal: true
          
          # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
          # source: spec/fixtures/service.proto
    
          require "twirp"
          require_relative "service_pb"
    
          module Example
            module HelloWorld
              class HelloWorldService < ::Twirp::Service
                package "example.hello_world"
                service "HelloWorld"
                rpc :Hello, HelloRequest, HelloResponse, ruby_method: :hello
              end
    
              class HelloWorldClient < ::Twirp::Client
                client_for HelloWorldService
              end
            end
          end
        EOF
      end
    end

    context "when using a well-named service" do
      # The `well_named_service.proto` fixture is copied from `service.proto` and updated
      # to name the service properly according to convention.
      #
      # Generate code gen request fixture:
      #   `./spec/support/create_fixture -b -f well_named_service_code_gen_request_pb.bin ./spec/fixtures/well_named_service.proto`
      let(:well_named_service_code_gen_request_pb) { fixture("well_named_service_code_gen_request_pb.bin").read }

      it "generates expected output" do
        response_pb = Twirp::ProtocPlugin.process(well_named_service_code_gen_request_pb)
        response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

        expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
        expect(response.file.size).to eq(1)
        expect(response.file.first.name).to eq("spec/fixtures/well_named_service_twirp.rb")
        expect(response.file.first.content).to eq <<~EOF
          # frozen_string_literal: true
          
          # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
          # source: spec/fixtures/well_named_service.proto
    
          require "twirp"
          require_relative "well_named_service_pb"
    
          module Example
            module HelloWorld
              class HelloWorldService < ::Twirp::Service
                package "example.hello_world"
                service "HelloWorldService"
                rpc :Hello, HelloRequest, HelloResponse, ruby_method: :hello
              end
    
              class HelloWorldClient < ::Twirp::Client
                client_for HelloWorldService
              end
            end
          end
        EOF
      end
    end

    context "when using a complex example with imported types and multiple services" do
      # Generate code gen request fixture:
      #   `./spec/support/create_fixture -b -f api_code_gen_request_pb.bin -o ./spec/fixtures/complex_example -I ./spec/fixtures/complex_example api.proto common/rpc/status.proto common/type/color.proto common/type/time_of_day.proto`
      let(:api_code_gen_request_pb) { fixture("complex_example/api_code_gen_request_pb.bin").read }

      context "when omitting the `skip-empty` option" do
        it "generates expected output" do
          response_pb = Twirp::ProtocPlugin.process(api_code_gen_request_pb)
          response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

          expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
          expect(response.file.size).to eq(4)

          first_file = response.file[0]
          expect(first_file.name).to eq("common/rpc/status_twirp.rb")
          expect(first_file.content).to eq <<~EOF
            # frozen_string_literal: true

            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: common/rpc/status.proto

            require "twirp"
            require_relative "status_pb"

            module Common
              module Rpc
                # No services found; To skip generating this file, specify `--twirp_ruby_opt=skip-empty`.
              end
            end
          EOF

          second_file = response.file[1]
          expect(second_file.name).to eq("common/type/color_twirp.rb")
          expect(second_file.content).to eq <<~EOF
            # frozen_string_literal: true

            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: common/type/color.proto

            require "twirp"
            require_relative "color_pb"

            module Common
              module Type
                # No services found; To skip generating this file, specify `--twirp_ruby_opt=skip-empty`.
              end
            end
          EOF

          third_file = response.file[2]
          expect(third_file.name).to eq("common/type/time_of_day_twirp.rb")
          expect(third_file.content).to eq <<~EOF
            # frozen_string_literal: true

            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: common/type/time_of_day.proto

            require "twirp"
            require_relative "time_of_day_pb"

            module Common
              module Type
                # No services found; To skip generating this file, specify `--twirp_ruby_opt=skip-empty`.
              end
            end
          EOF

          fourth_file = response.file[3]
          expect(fourth_file.name).to eq("api_twirp.rb")
          expect(fourth_file.content).to eq <<~EOF
            # frozen_string_literal: true

            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: api.proto

            require "twirp"
            require_relative "api_pb"

            module Api
              class GreetService < ::Twirp::Service
                package "api"
                service "GreetService"
                rpc :SayHello, HelloRequest, HelloResponse, ruby_method: :say_hello
                rpc :SayGoodbye, GoodbyeRequest, GoodbyeResponse, ruby_method: :say_goodbye
                rpc :ChangeColor, ::Common::Type::Color, ChangeColorResponse, ruby_method: :change_color
              end
            
              class GreetClient < ::Twirp::Client
                client_for GreetService
              end

              class StatusService < ::Twirp::Service
                package "api"
                service "StatusService"
                rpc :GetStatus, StatusRequest, ::Common::Rpc::Status, ruby_method: :get_status
                rpc :GetTimeOfDay, TimeOfDayRequest, ::Common::Type::TimeOfDay, ruby_method: :get_time_of_day
              end
            
              class StatusClient < ::Twirp::Client
                client_for StatusService
              end
            end
          EOF
        end
      end

      context "when specifying the `skip-empty` option" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -f api_code_gen_request_skip_empty_pb.bin -p skip-empty -o ./spec/fixtures/complex_example -I ./spec/fixtures/complex_example api.proto common/rpc/status.proto common/type/color.proto common/type/time_of_day.proto`
        let(:api_code_gen_request_skip_empty_pb) { fixture("complex_example/api_code_gen_request_skip_empty_pb.bin").read }

        it "generates expected output" do
          response_pb = Twirp::ProtocPlugin.process(api_code_gen_request_skip_empty_pb)
          response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

          expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
          expect(response.file.size).to eq(1)

          first_file = response.file[0]
          expect(first_file.name).to eq("api_twirp.rb")
          expect(first_file.content).to eq <<~EOF
            # frozen_string_literal: true
  
            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: api.proto
  
            require "twirp"
            require_relative "api_pb"
  
            module Api
              class GreetService < ::Twirp::Service
                package "api"
                service "GreetService"
                rpc :SayHello, HelloRequest, HelloResponse, ruby_method: :say_hello
                rpc :SayGoodbye, GoodbyeRequest, GoodbyeResponse, ruby_method: :say_goodbye
                rpc :ChangeColor, ::Common::Type::Color, ChangeColorResponse, ruby_method: :change_color
              end
            
              class GreetClient < ::Twirp::Client
                client_for GreetService
              end
  
              class StatusService < ::Twirp::Service
                package "api"
                service "StatusService"
                rpc :GetStatus, StatusRequest, ::Common::Rpc::Status, ruby_method: :get_status
                rpc :GetTimeOfDay, TimeOfDayRequest, ::Common::Type::TimeOfDay, ruby_method: :get_time_of_day
              end
            
              class StatusClient < ::Twirp::Client
                client_for StatusService
              end
            end
          EOF
        end
      end
    end
  end
end
