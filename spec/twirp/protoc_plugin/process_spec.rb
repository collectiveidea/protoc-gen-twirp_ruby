# frozen_string_literal: true

RSpec.describe Twirp::ProtocPlugin do
  describe "#process" do
    describe "parameter validation" do
      context "when passing an invalid parameter" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p unrecognized -f service_code_gen_request_unrecognized_param_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_unrecognized_param_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "Invalid option: unrecognized")
        end
      end

      context "when passing the `skip-empty` flag" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p skip-empty -f service_code_gen_request_skip_empty_flag_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_skip_empty_flag_pb.bin").read }

        it "outputs a deprecation warning to stderr" do
          allow($stderr).to receive(:<<)

          Twirp::ProtocPlugin.process(request_pb)

          expect($stderr).to have_received(:<<).with("WARNING: The `skip-empty` flag is deprecated and will be removed next release; it is now the default behavior.")
        end
      end

      context "when passing an empty value for the generate flag" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p generate= -f service_code_gen_request_generate_param_missing_value_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_generate_param_missing_value_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "Unexpected missing value for generate option. Please supply one of: service, client, both.")
        end
      end

      context "when passing an invalid value for the generate flag" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -p generate=bad -f service_code_gen_request_generate_param_invalid_value_pb.bin ./spec/fixtures/service.proto`
        let(:request_pb) { fixture("service_code_gen_request_generate_param_invalid_value_pb.bin").read }

        it "raises an argument error" do
          expect {
            Twirp::ProtocPlugin.process(request_pb)
          }.to raise_error(ArgumentError, "The generate value must be one of: service, client, both. Unexpectedly received: bad")
        end
      end
    end

    context "when using the example from the original go plugin" do
      # The `service.proto` fixture is from:
      #   https://github.com/arthurnn/twirp-ruby/blob/v1.11.0/example/hello_world/service.proto
      #
      # Generate code gen request fixture:
      #   `./spec/support/create_fixture -b -f service_code_gen_request_pb.bin ./spec/fixtures/service.proto`
      let(:service_code_gen_request_pb) { fixture("service_code_gen_request_pb.bin").read }

      it "generates expected output" do
        response_pb = Twirp::ProtocPlugin.process(service_code_gen_request_pb)
        response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

        expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
        expect(response.file.size).to eq(1)
        expect(response.file.first.name).to eq("spec/fixtures/service_twirp.rb")
        # Match the general output of the 1.11.0 go plugin when ran against the same service.proto.
        # See: https://github.com/arthurnn/twirp-ruby/blob/v1.11.0/example/hello_world/service_twirp.rb
        expect(response.file.first.content).to eq <<~EOF
          # frozen_string_literal: true
          
          # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
          # source: spec/fixtures/service.proto
    
          require "twirp"
          require_relative "service_pb"
    
          module Example
            module HelloWorld
              class HelloWorldService < ::Twirp::Service
                package "example.hello_world"
                service "HelloWorld"
                rpc :Hello, HelloRequest, HelloResponse, ruby_method: :hello
              end
    
              class HelloWorldClient < ::Twirp::Client
                client_for HelloWorldService
              end
            end
          end
        EOF
      end
    end

    context "when using a well-named service" do
      # The `well_named_service.proto` fixture is copied from `service.proto` and updated
      # to name the service properly according to convention.
      #
      # Generate code gen request fixture:
      #   `./spec/support/create_fixture -b -f well_named_service_code_gen_request_pb.bin ./spec/fixtures/well_named_service.proto`
      let(:well_named_service_code_gen_request_pb) { fixture("well_named_service_code_gen_request_pb.bin").read }

      it "generates expected output" do
        response_pb = Twirp::ProtocPlugin.process(well_named_service_code_gen_request_pb)
        response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

        expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
        expect(response.file.size).to eq(1)
        expect(response.file.first.name).to eq("spec/fixtures/well_named_service_twirp.rb")
        expect(response.file.first.content).to eq <<~EOF
          # frozen_string_literal: true
          
          # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
          # source: spec/fixtures/well_named_service.proto
    
          require "twirp"
          require_relative "well_named_service_pb"
    
          module Example
            module HelloWorld
              class HelloWorldService < ::Twirp::Service
                package "example.hello_world"
                service "HelloWorldService"
                rpc :Hello, HelloRequest, HelloResponse, ruby_method: :hello
              end
    
              class HelloWorldClient < ::Twirp::Client
                client_for HelloWorldService
              end
            end
          end
        EOF
      end
    end

    context "when using a complex example with imported types and multiple services" do
      context "when run without any options" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -f api_code_gen_request_pb.bin -o ./spec/fixtures/complex_example -I ./spec/fixtures/complex_example api.proto common/rpc/status.proto common/type/color.proto common/type/time_of_day.proto`
        let(:api_code_gen_request_pb) { fixture("complex_example/api_code_gen_request_pb.bin").read }

        it "generates a single file containing two services and two clients" do
          response_pb = Twirp::ProtocPlugin.process(api_code_gen_request_pb)
          response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

          expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
          expect(response.file.size).to eq(1)

          first_file = response.file[0]
          expect(first_file.name).to eq("api_twirp.rb")
          expect(first_file.content).to eq <<~EOF
            # frozen_string_literal: true
  
            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: api.proto
  
            require "twirp"
            require_relative "api_pb"
  
            module API
              class GreetService < ::Twirp::Service
                package "api"
                service "GreetService"
                rpc :SayHello, HelloRequest, HelloResponse, ruby_method: :say_hello
                rpc :SayGoodbye, GoodbyeRequest, GoodbyeResponse, ruby_method: :say_goodbye
                rpc :ChangeColor, ::Common::Type::Color, ChangeColorWrapper::Response, ruby_method: :change_color
              end
            
              class GreetClient < ::Twirp::Client
                client_for GreetService
              end
  
              class StatusService < ::Twirp::Service
                package "api"
                service "StatusService"
                rpc :GetStatus, ::Google::Protobuf::Empty, ::Common::RPC::Status, ruby_method: :get_status
                rpc :GetTimeOfDay, TimeOfDayRequest, ::Common::Type::TimeOfDay, ruby_method: :get_time_of_day
              end
            
              class StatusClient < ::Twirp::Client
                client_for StatusService
              end
            end
          EOF
        end
      end

      context "when specifying the `generate=both` option" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -f api_code_gen_request_generate_both_pb.bin -p generate=both -o ./spec/fixtures/complex_example -I ./spec/fixtures/complex_example api.proto common/rpc/status.proto common/type/color.proto common/type/time_of_day.proto`
        let(:api_code_gen_request_generate_both_pb) { fixture("complex_example/api_code_gen_request_generate_both_pb.bin").read }

        it "generates a single file containing two services and two clients" do
          response_pb = Twirp::ProtocPlugin.process(api_code_gen_request_generate_both_pb)
          response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

          expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
          expect(response.file.size).to eq(1)

          first_file = response.file[0]
          expect(first_file.name).to eq("api_twirp.rb")
          expect(first_file.content).to eq <<~EOF
            # frozen_string_literal: true
  
            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: api.proto
  
            require "twirp"
            require_relative "api_pb"
  
            module API
              class GreetService < ::Twirp::Service
                package "api"
                service "GreetService"
                rpc :SayHello, HelloRequest, HelloResponse, ruby_method: :say_hello
                rpc :SayGoodbye, GoodbyeRequest, GoodbyeResponse, ruby_method: :say_goodbye
                rpc :ChangeColor, ::Common::Type::Color, ChangeColorWrapper::Response, ruby_method: :change_color
              end
            
              class GreetClient < ::Twirp::Client
                client_for GreetService
              end
  
              class StatusService < ::Twirp::Service
                package "api"
                service "StatusService"
                rpc :GetStatus, ::Google::Protobuf::Empty, ::Common::RPC::Status, ruby_method: :get_status
                rpc :GetTimeOfDay, TimeOfDayRequest, ::Common::Type::TimeOfDay, ruby_method: :get_time_of_day
              end
            
              class StatusClient < ::Twirp::Client
                client_for StatusService
              end
            end
          EOF
        end
      end

      context "when specifying the `generate=service` option" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -f api_code_gen_request_generate_service_pb.bin -p generate=service -o ./spec/fixtures/complex_example -I ./spec/fixtures/complex_example api.proto common/rpc/status.proto common/type/color.proto common/type/time_of_day.proto`
        let(:api_code_gen_request_generate_service_pb) { fixture("complex_example/api_code_gen_request_generate_service_pb.bin").read }

        it "generates a single file with only two services" do
          response_pb = Twirp::ProtocPlugin.process(api_code_gen_request_generate_service_pb)
          response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

          expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
          expect(response.file.size).to eq(1)

          first_file = response.file[0]
          expect(first_file.name).to eq("api_twirp.rb")
          expect(first_file.content).to eq <<~EOF
            # frozen_string_literal: true
  
            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: api.proto
  
            require "twirp"
            require_relative "api_pb"
  
            module API
              class GreetService < ::Twirp::Service
                package "api"
                service "GreetService"
                rpc :SayHello, HelloRequest, HelloResponse, ruby_method: :say_hello
                rpc :SayGoodbye, GoodbyeRequest, GoodbyeResponse, ruby_method: :say_goodbye
                rpc :ChangeColor, ::Common::Type::Color, ChangeColorWrapper::Response, ruby_method: :change_color
              end
  
              class StatusService < ::Twirp::Service
                package "api"
                service "StatusService"
                rpc :GetStatus, ::Google::Protobuf::Empty, ::Common::RPC::Status, ruby_method: :get_status
                rpc :GetTimeOfDay, TimeOfDayRequest, ::Common::Type::TimeOfDay, ruby_method: :get_time_of_day
              end
            end
          EOF
        end
      end

      context "when specifying the `generate=client` option" do
        # Generate code gen request fixture:
        #   `./spec/support/create_fixture -b -f api_code_gen_request_generate_client_pb.bin -p generate=client -o ./spec/fixtures/complex_example -I ./spec/fixtures/complex_example api.proto common/rpc/status.proto common/type/color.proto common/type/time_of_day.proto`
        let(:api_code_gen_request_generate_client_pb) { fixture("complex_example/api_code_gen_request_generate_client_pb.bin").read }

        it "generates a single file with only two clients without the `client_for` DSL" do
          response_pb = Twirp::ProtocPlugin.process(api_code_gen_request_generate_client_pb)
          response = Google::Protobuf::Compiler::CodeGeneratorResponse.decode(response_pb)

          expect(response.supported_features).to eq(Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL)
          expect(response.file.size).to eq(1)

          first_file = response.file[0]
          expect(first_file.name).to eq("api_twirp.rb")
          expect(first_file.content).to eq <<~EOF
            # frozen_string_literal: true
  
            # Generated by the protoc-gen-twirp_ruby gem v#{Twirp::ProtocPlugin::VERSION}. DO NOT EDIT!
            # source: api.proto
  
            require "twirp"
            require_relative "api_pb"
  
            module API
              class GreetClient < ::Twirp::Client
                package "api"
                service "GreetService"
                rpc "SayHello", HelloRequest, HelloResponse, ruby_method: :say_hello
                rpc "SayGoodbye", GoodbyeRequest, GoodbyeResponse, ruby_method: :say_goodbye
                rpc "ChangeColor", ::Common::Type::Color, ChangeColorWrapper::Response, ruby_method: :change_color
              end
  
              class StatusClient < ::Twirp::Client
                package "api"
                service "StatusService"
                rpc "GetStatus", ::Google::Protobuf::Empty, ::Common::RPC::Status, ruby_method: :get_status
                rpc "GetTimeOfDay", TimeOfDayRequest, ::Common::Type::TimeOfDay, ruby_method: :get_time_of_day
              end
            end
          EOF
        end
      end
    end
  end
end
