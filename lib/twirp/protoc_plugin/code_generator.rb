# frozen_string_literal: true

require_relative "../../google/protobuf/compiler/plugin_pb"
require_relative "../../core_ext/string/camel_case"
require_relative "../../core_ext/string/snake_case"
require_relative "descriptor_ext/service_descriptor_proto_ext"
require "stringio"

module Twirp
  module ProtocPlugin
    class CodeGenerator
      # @param proto_file [Google::Protobuf::FileDescriptorProto]
      # @param relative_ruby_protobuf [String] e.g. "example_rb.pb"
      # @param options [Hash{Symbol => Boolean, Symbol}]
      #   * :skip_empty [Boolean] indicating whether generation should skip creating a twirp file
      #       for proto files that contain no services.
      #   * :generate [Symbol] one of: :service, :client, or :both.
      def initialize(proto_file, relative_ruby_protobuf, options)
        @proto_file = proto_file
        @relative_ruby_protobuf = relative_ruby_protobuf
        @options = options
      end

      # @return [String] the generated Twirp::Ruby code for the proto_file
      def generate
        output = StringIO.new
        output << <<~START
          # frozen_string_literal: true
          
          # Generated by the protoc-gen-twirp_ruby gem v#{VERSION}. DO NOT EDIT!
          # source: #{@proto_file.name}

          require "twirp"
          require_relative "#{@relative_ruby_protobuf}"
      
        START

        indent_level = 0
        modules = @proto_file.ruby_module&.delete_prefix("::")&.split("::") || []

        modules.each do |mod|
          output << line("module #{mod}", indent_level)
          indent_level += 1
        end

        unless @proto_file.has_service?
          output << line("# No services found; To skip generating this file, specify `--twirp_ruby_opt=skip-empty`.", indent_level)
        end

        @proto_file.service.each_with_index do |service, index| # service: <Google::Protobuf::ServiceDescriptorProto>
          # Add newline between definitions when multiple are generated
          output << "\n" if index > 0

          if %i[service both].include?(@options[:generate])
            generate_service_class(output, indent_level, service)
          end

          if @options[:generate] == :both
            # Space between generated service and client when generating both
            output << "\n"

            generate_client_class_for_service(output, indent_level, service)
          elsif @options[:generate] == :client
            # When generating only the client, we can't use the `client_for` DSL.
            generate_client_class_standalone(output, indent_level, service)
          end
        end

        modules.each do |_|
          indent_level -= 1
          output << line("end", indent_level)
        end

        output.string
      end

      private

      # Format a string by adding a trailing new line and indenting 2 spaces
      # for every indent level.
      #
      # @param input [String] the input string to format
      # @param indent_level [Integer] the number of double spaces to indent. Default 0.
      # @return [String] the input properly indented with a tailing newline added
      def line(input, indent_level = 0)
        "#{"  " * indent_level}#{input}\n"
      end

      # Generates a Twirp::Service subclass for the given service class, adding the
      # string to the output.
      #
      # @param output [#<<] the output to append the generated service code to
      # @param indent_level [Integer] the number of double spaces to indent the generated code by
      # @param service [Google::Protobuf::ServiceDescriptorProto]
      # @return [void]
      def generate_service_class(output, indent_level, service)
        service_name = service.name
        service_class_name = service.service_class_name

        # Generate service class
        output << line("class #{service_class_name} < ::Twirp::Service", indent_level)
        output << line("  package \"#{@proto_file.package}\"", indent_level) unless @proto_file.package.to_s.empty?
        output << line("  service \"#{service_name}\"", indent_level)
        service["method"].each do |method| # method: <Google::Protobuf::MethodDescriptorProto>
          input_type = convert_to_ruby_type(method.input_type, @proto_file.ruby_module)
          output_type = convert_to_ruby_type(method.output_type, @proto_file.ruby_module)
          ruby_method_name = method.name.snake_case

          output << line("  rpc :#{method.name}, #{input_type}, #{output_type}, ruby_method: :#{ruby_method_name}", indent_level)
        end
        output << line("end", indent_level)
      end

      # Generates a Twirp::Client subclass for the given service class, adding the
      # string to the output.
      #
      # @param output [#<<] the output to append the generated service code to
      # @param indent_level [Integer] the number of double spaces to indent the generated code by
      # @param service [Google::Protobuf::ServiceDescriptorProto]
      # @return [void]
      def generate_client_class_for_service(output, indent_level, service)
        output << line("class #{service.client_class_name} < ::Twirp::Client", indent_level)
        output << line("  client_for #{service.service_class_name}", indent_level)
        output << line("end", indent_level)
      end

      # Generates a Twirp::Client subclass standalone, without using the `client_for` DSL because
      # there is no corresponding service to reference.
      #
      # This essentially in-lines the `client_for` logic from
      # https://github.com/arthurnn/twirp-ruby/blob/v1.11.0/lib/twirp/client.rb#L31
      #
      # @param output [#<<] the output to append the generated service code to
      # @param indent_level [Integer] the number of double spaces to indent the generated code by
      # @param service [Google::Protobuf::ServiceDescriptorProto]
      # @return [void]
      def generate_client_class_standalone(output, indent_level, service)
        output << line("class #{service.client_class_name} < ::Twirp::Client", indent_level)
        output << line("  package \"#{@proto_file.package}\"", indent_level) unless @proto_file.package.to_s.empty?
        output << line("  service \"#{service.name}\"", indent_level)
        service["method"].each do |method| # method: <Google::Protobuf::MethodDescriptorProto>
          input_type = convert_to_ruby_type(method.input_type, @proto_file.ruby_module)
          output_type = convert_to_ruby_type(method.output_type, @proto_file.ruby_module)
          ruby_method_name = method.name.snake_case

          # TRICKY: The service `rpc` DSL accepts a method symbol, but the client `rpc` DSL expects a string.
          output << line("  rpc \"#{method.name}\", #{input_type}, #{output_type}, ruby_method: :#{ruby_method_name}", indent_level)
        end
        output << line("end", indent_level)
      end

      # Converts either a package string like ".some.example.api" or a namespaced
      # message like "google.protobuf.Empty" to an Array of Strings that can be
      # used as Ruby constants (when joined with "::").
      #
      # ".some.example.api" becomes ["", Some", "Example", "Api"]
      # "google.protobuf.Empty" becomes ["Google", "Protobuf", "Empty"]
      #
      # @param package_or_message [String]
      # @return [Array<String>]
      def split_to_constants(package_or_message)
        package_or_message
          .split(".")
          .map { |s| s.camel_case }
      end

      # Converts a protobuf message type to a string containing
      # the equivalent Ruby constant.
      #
      # Examples:
      #
      #   convert_to_ruby_type("example_message") => "ExampleMessage"
      #   convert_to_ruby_type(".foo.bar.example_message") => "::Foo::Bar::ExampleMessage"
      #   convert_to_ruby_type(".foo.bar.example_message", "::Foo") => "Bar::ExampleMessage"
      #   convert_to_ruby_type(".foo.bar.example_message", "::Foo::Bar") => "ExampleMessage"
      #   convert_to_ruby_type("google.protobuf.Empty", "::Foo") => "Google::Protobuf::Empty"
      #
      # @param message_type [String]
      # @param current_module [String, nil]
      # @return [String]
      def convert_to_ruby_type(message_type, current_module = nil)
        s = split_to_constants(message_type).join("::")

        if !current_module.nil? && s.start_with?(current_module)
          # Strip current module and trailing "::" prefix
          s[current_module.size + 2..]
        else
          s
        end
      end
    end
  end
end
